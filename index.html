<!DOCTYPE html>
<html>
	<head>
		<title>Showcase</title>
		<link rel="stylesheet" href="styling.css">
	</head>
	<body>
		<div class="envelop">
			
			<div class="box cell1">
				<text id="intro" style="text-align:center;">Hi! My name is Greg.</text>
				<p>I've been coding on and off for about a year and a half working on my own projects involving primarily PHP, MySQL, and JavaScript. To the right you will find descriptions of said projects and some of the other coding activities I've undertaken lately. You can click on headers to visit project repositories.
			</div>
			<div class="box cell2">
				<h1><a href="https://github.com/Konntroll/EternalDraftSim_v0.1">Eternal Card Game Draft Simulator v0.1</a></h1>
				<p>This is the latest project that I worked on up until May. Building on my previous projects described below it has a far more substantial JavaScript component while still making extensive use of PHP and MySQL with a touch of JSON.
				<p>The draft system implemented in Eternal is asynchronous, i.e. instead of passing packs around the table the player receives a range of packs from the game’s database where they are stored after other players made picks from them. Because of this, the player is never constrained for time when making picks and this simulator is written to reflect this mechanic.
				<p>The booster generator function differs little from those used in previous projects and is a revamped version thereof pulling cards from a MySQL database to produce 12-card boosters of the game.
				<p>The draft mechanism is very different however because of peculiarities of asynchronous drafting in Eternal. It runs a set number of times making picks according to a mechanism similar to the one used for picks in DraftSim_v0.1A and producing a multidimensional array of numbers corresponding to card numbers that is then imploded into a single string and stored in a MySQL database. It doesn’t need to run again thereafter.
				<p>Once loaded the UI part of the program queries the drafts database for the top draft string and its entry number storing them in variables. It then deletes the entry from its position at the top of the database and reattaches it at the bottom. The variables are then passed to the JS component of the UI which splits the string into a multidimensional array equivalent to the one originally produced by the draft mechanism.
				<p>The first booster is then displayed to the player allowing them to add a card of their choice to their main pool by clicking on the card’s image. The pick is shown on the right hand side of the screen in its reduced form that is determined by card data pulled from a JSON file and stored in a variable by the program during run time so as not to make continuous calls to the server to retrieve these data from the TET database.
				<p>Clicking on a card in the pool will put it into sideboard, which can be accessed by clicking on the Sideboard “button” above the pool column. Clicking on cards in the sideboard sends them back to main deck. To return to the main deck view the user can click the Maindeck “button”.
				<p>The graph above the UI buttons and the pool charts the cost curve of the cards in the deck informing the player’s pick decisions. This is implemented using Flotr2 library.
				<p>Once the draft is over (i.e. all 48 picks have been made) the program returns the remaining array of cards back to the server with the original DB entry number assigned to one of the now empty end arrays. 
				<p>The receiving side of the code reads the entry number and deletes the empty elements of the sub-arrays appending full 12-card booster arrays to the front and imploding the multidimensional array back into a string. It then uses the entry number to find the original entry and overwrite it with the new input thus driving towards human-determined draft sequences that should ideally replace the ones generated by machine.
				<p>If the draft is not finished for any reason, the original entry remains intact at the end of the DB and will be accessed again after all other entries before it have been processed.
				<p>I’m particularly fond of the back end mechanisms of this application and I feel that it is a reasonable take on the original experience, sans the gameplay. The UI component leaves much to be desired yet but I believe that it is definitely a step up from the previous Magic draft simulators.
			</div>
			<div class="box cell3">
				<h1><a href="https://github.com/Konntroll/DraftSim_v0.1A">DraftSim_v0.1A</a></h1>
				<p>Magic the Gathering draft simulator in PHP using JavaScript and MySQL
				<p>This is the first iteration of the Magic draft simulator that I worked on. It is designed for the Battle for Zendikar set of cards but could be adapted for use with any other set.
				<p>This code uses a separate function to generate boosters in the form of arrays of numbers that correspond to actual card numbers. These numbers are pulled from a MySQL database which stores other card parameters that can be used by the computer to inform card picks during drafting.
				<p>It uses session variables to store information over the course of a draft and assigns 3 unopened generated boosters to each of the 8 players (1 human, 7 simulated) and uses a JavaScript-based "interface" to display the first booster to the human player and to feed his or her pick to the card picking portion of the program via AJAX.
				<p>This latter piece of code adds the card picked by the player to his or her card pool and removes it from the corresponding booster. It then makes a pick in each of the remaining 7 boosters likewise storing the picks in the card pools of respective players. The boosters are then rotated so that the human player sees the next booster less the card picked by his or her opponent on the virtual right from him of her.
				<p>This continues until the first eight boosters are exhausted whereupon the program moves to the next round opening another set of eight boosters. It repeats the process described above but in a different direction as this would work at an actual table. The third round is identical to the first one.
				<p>As the draft progresses the picking part of the code goes through increasingly complex evaluations of the cards in each virtual player's card pool to inform the picks it makes in each booster. This mechanism is rather crude and generic but scalable and refinable.
				<p>Overall I believe that the resulting code provides a reasonable if very approximate take on what an actual draft would be like. It's not something to use as a basis for judgment of the set and related strategies but can give you enough of an idea of how actual Battle for Zendikar drafting goes not to feel overwhelmed at the table when sitting down to play the first few times.
			</div>
			<div class="box cell4">
				<h1>A stint in C++</h1>
				<p>Encouraged by a friend I stopped my work on the Eternal draft simulator to try my hand in C++. I took a vacation to learn some of the basics of the language and was able to write as handful of simple console-based programs including a version of the number-to-words converter like the one I posted as a kata on codewars.com and an implemen-tation of Blackjack and a Russian card game called Durak.
				<p>I’ve also learned a few things about Unity and some C# coding and tried building and scripting some levels similar in a way to things that my friend’s company was working on.
				<p>In the end, they offered me some small jobs but felt overwhelmed by the complexity of the proprietary engine that they were using and decided not to test their patience. 
				<p>Moving on, I will probably give my last project a thorough workover and/or start a new project in the near future. However, I feel that my progress is greatly hampered outside of communities where actual work and projects are being done which is one of the major reasons for my application with you.
			</div>
			<div class="box cell5">
				<h1><a href="https://github.com/Konntroll/DraftSim_v0.1B">DraftSim_v0.1B</a></h1>
				<p>Magic the Gathering draft simulator in PHP using OOP, JavaScript, and MySQL
				<p>This is the second iteration of my Magic draft simulator (version 0.1B). It is similar to version 0.1A in some respects but differs a good deal in many others.
				<p>Designed to work with the Kaladesh set of Magic cards this program is ”hardwired" for the set and would be impossible to use properly with a different set without major rewrites. This is due to substantial changes in the pick mechanism that were implemented to refine the card picking process and make it a bit more realistic and consistent. The program makes wide use of objects to facilitate evaluations and tracking of player and card pick data.
				<p>Similarly to the previous version, this one uses a separate booster generating function that has been adjusted to accommodate the peculiarities of Kaladesh (namely, the Inventions subset) and to generate boosters not as arrays of numbers but as arrays of card objects with parameters pulled from a MySQL database. This has reduced the number of MySQL queries required for the program.
				<p>The interface part of the code is largely unchanged, except for creation of player objects assigned to session variables for use in the course of the draft.
				<p>Classes used in the program are defined in a separate file.
				<p>The drafting mechanism has undergone the most extensive changes and is now split into two parts. One of them keeps track of draft progress parameters such as current round, player, booster pass direction, etc. The booster carrousel has become a lot more transparent and concise here.
				<p>The other part of the drafting mechanism is the pick function which is now the most extensive part of the code that includes three large switch statements each iterating over most of the cards in the set individually and making adjustments to their value rating (LSV value) in order to inform the final pick.
				<p>Other than that, this function also takes care of color considerations pushing simulated players to commit to a certain pair of colors in their card pool that have the most valuable cards, checking for splashable cards and ways to splash them as the virtual player considers its picks, and reading signals by evaluating the total value of cards passed to the player in each color adjusted by their number. It also keeps track of the mana curve.
				<p>This approach has made it possible to handle drafting more or less as a real player would, giving preference to specific cards and adjusting values not only of the cards to be picked but also of those that have already made it into the player’s card pool. With further work the OO aspect of the code could make it possible to introduce strategies and/or deck archetypes to further refine simulated drafting.
				<p>The trade off here is, of course, poor scalability. Each new set, whether in the same block or not, will require rewriting of large sections of the pick function with careful analysis of the new set’s peculiarities. Nevertheless, given that sets are published relatively infrequently I believe it would be quite possible to implement this approach in a dedicated production environment.
			</div>
		</div>
	</body>
</html>
